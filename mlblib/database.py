#!/usr/bin/python
from cassandra.cluster import Cluster
from cassandra.query import BatchStatement
from cassandra import ConsistencyLevel
import settings
import scrapeUtils
import cql

##################################################################################################################
# Class: Database

# Explained: Run a cassandra instance on your local machine with ./cassandra from cassandra install
# directory at 127.0.0.1
# This class connects to that instance and every instance in its cluster
# Also contains functions for setting up tables and inserting data into cassandra
##################################################################################################################


def fetchCQL(filename):
    with open(filename) as f:
        cqlQuery = f.read()
    return cqlQuery


def createKeyspace(keyspace):
    cluster = Cluster()
    session = cluster.connect()
    session.execute('CREATE KEYSPACE ' + str(keyspace) + " WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };")


#
# Input: table (name of table), keyspace (name of keyspace)
# Creates a table and inserts it into a keyspace
#
def createTable(keyspace):
    cluster = Cluster()
    session = cluster.connect(keyspace)

    # ---Use this code to make your initial pitch table---
    session.execute(fetchCQL(settings.sqlDir + 'CQL_test.cql'))


# inserts data from a filename and into a keyspace: k and a table: table

def insertData(fileName, keyspace, table):
    # ---This line will insert pitch data into your table for a given inning file---
    # ---Currently, the primary key is the atbat_num, and the game_id---

    # not sure if this is redundant or necessary should look into it
    cluster = Cluster()
    session = cluster.connect(keyspace)

    data = scrapeUtils.parsePitch(settings.localDir + fileName, table)
    for line in data:
        session.execute(line)


def testData(k):
    cluster = Cluster()
    keyspace = k
    session = cluster.connect(keyspace)
    # ---this will just select some data and spit it out, currently used in test---
    connection = session.execute('SELECT * FROM pitches LIMIT 5')
    pitchList = []
    for pitch in connection:
        foo = str("Pitcher ID %s - %s" % (pitch.pitcher_id, pitch.pitch_type))
        pitchList.append(foo)
        print(pitchList)
        # print("Pitcher ID %s - %s" % (pitch.pitcher_id, pitch.pitch_type))
    return (pitchList)


def selectPitcher(keyspace, table, pitcher):
    cluster = Cluster()
    session = cluster.connect(keyspace)

    data = session.execute('SELECT * FROM ' + str(table))
    for pitch in data:
        if pitch.pitcher_id == pitcher:
            print(str(pitch))


#
# Function batchDataInsert inserts data into table in a batchy fashion
# Takes a session, table, and data
# Data is a list of tuples
# Generally data will be generated by scrapeUtils.parsePitchRewrite
# This function expects for the number of records in EACH tuple to match the number of columns in the target table
# Otherwise it will break
# The reason this function takes a session is so we can open one session and insert many batches without reconnecting
def batchDataInsert(session, data, table):

    #tableDict is a dictionary mapping between the table name that the user provides and the columns in that table
    #the columns will now be stored as text files with columns seperated by newlines in docs directory
    #any new tables add the mapping here
    #probably a better way to do this, feel free to change it
    tableDict = {"pitches": settings.docDir + "all_pitch_test_columns.txt",
                 "pitches_all_cols": settings.docDir + "all_db_columns.txt",
                 }

    # opens the column file from docs corresponding to the table you chose
    with open(tableDict[table]) as f:
        # returns a list of columns from your table
        read_data = f.read().splitlines()

    # generates a string like "col1,col2,col3...."
    columns = ','.join(read_data)
    # generates the appropriate number of ? marks for the number of columns in your table
    quests = ('?,' * (len(read_data) - 1)) + '?'

    prepareString = "INSERT INTO " + table + "(" + columns + ")" + "VALUES" + "(" + quests + ")"


    insert_data = session.prepare(prepareString)
    batch = BatchStatement(consistency_level=ConsistencyLevel.QUORUM)
    for row in data:
        batch.add(insert_data, row)
    print("Inserting data batch into database")
    session.execute(batch)

#function inserts a single row into cassandra database table
#Takes datadict with column:value format
#Inserts 1 row into table available at session
#Meant to be used by iterating through parsePitchRewrite return value: a list of dataDicts
def singleRowInsert(session, dataDict, table):

        cols = dataDict.keys()
        vals = dataDict.values()
        print(cols)

        # generates a string like "col1,col2,col3...."
        colString = ','.join(cols)
        # generates the appropriate number of ? marks for the number of columns in your table
        quests = ('?,' * (len(cols) - 1)) + '?'

        prepareString = "INSERT INTO " + table + "(" + colString + ")" + "VALUES" + "(" + quests + ")"

        insert_data = session.prepare(prepareString)
        #insertion = session.add(insert_data, vals)
        print("Inserting row into database")
        session.execute(insert_data, vals)

def generateTableFromDoc(session,doc,tableName):
    columnList = []

    with open(doc) as f:
        columnNames = f.read().splitlines()
    for line in columnNames:
        if line.startswith('--*'):
            continue
        if line.startswith('--'):
            #take from 3rd character when line is commented... make sure there's a space after -- for this to work
            line = line[3:]
        #The below could be optimized to make only one call to split() if things are slow
        newstr = line.split()[0] + ' ' + line.split()[2]
        columnList.append(newstr)

    strCols = ','.join(columnList)
    exStr = 'CREATE TABLE ' + tableName + ' (' + strCols + ', PRIMARY KEY(game_id, inning_num, p_num));'
    print(exStr)
    session.execute(exStr)








